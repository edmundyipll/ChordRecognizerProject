FEATURE VtoIProgression	
	purpose: to find out all target matchTuple, with the requirement of V to I progression, within a given bar limit

	input: intervalA,
		   matchTupleA,
		   ProgressionIntervalChoice,
		   bar limit

	output: list of next target matchTuple

	unpack matchTupleA such that
	(cnameA, chordTypeA, inverionA, romanA, chordFunctionA, tonicA, groupNoA) = matchTupleA

	if choice is ChangedBaseline:
		matchTupleBList = all matchTuple inside all target type interval from intervalA to ((intervalA + 5)/2)
	else:
		matchTupleBList = all matchTuple inside all target type interval form intervalA to (bar limit/2) 

	for matchTupleB in matchTupleBList:

		unpack matchTupleA such that
		(cnameB, chordTypeB, inverionB, romanB, chordFunctionB, tonicB, groupNoB) = matchTupleB

		if romanB is 'V' && tonicA[0] not equal tonicB[0]:

			if choice is ChangedBaseline:
				matchTupleCList = all matchTuple inside all target type interval from intervalB to ((intervalB + 5)/2)
			else:
				matchTupleCList = all matchTuple inside all target type interval form intervalB to (bar limit/2) 

			for matchTupleC in matchTupleCList:

				unpack matchTupleC such that
				(cnameC, chordTypeC, inversionC, romanC, chordFunctionC, tonicC, groupNoC) = matchTupleC

				if tonicB = tonicC && 
				   romanC is 'I' && 
				   (chordTypeA, chordTypeC) is [(Major 7th, Major) / (Major, Major) / (Minor, Minor)]:

					eqvMatchTupleC = equivalent matchTuple of matchTupleC which has tonic equal to tonicA

					if matchTupleA to eqvMatchTupleC is a valid progression:

						append matchTupleC to next target matchTuple list

					eqvMatchTupleB = equivalent matchTuple of matchTupleB which has tonic equal to tonicA

					if matchTupleA to eqvMatchTupleB is a valid progression:

						append matchTupleB to next target matchTuple list



